# Cyber Math – Python Programs for Real-Life Security


## Overview of the Project
**Cyber Math** is a collection of 30+ small, educational Python programs that demonstrate how fundamental concepts from **number theory** and **mathematics** are used in real-world **cybersecurity** and **cryptography**.
Each program implements a classic mathematical idea (prime testing, modular arithmetic, Chinese Remainder Theorem, etc.) that powers modern encryption systems like digital signatures, and secure hashing.
This project is designed as a **Computer Science / Cybersecurity assignment** to help students understand the beautiful connection between pure mathematics and practical information security.

- Finding prime numbers → used in WhatsApp encryption  
- Doing calculations "modulo" → used when you log into Instagram  
- Chinese Remainder Theorem → used in RSA (bank-level security)  
- Miller-Rabin test → used to check if a 1000-digit number is prime in milliseconds!


## Features 

| No. | File Name                        | What You Will Learn                              | Real-Life Use in Security |
|-----|----------------------------------|--------------------------------------------------|---------------------------|
| 1   | `01_factorial.py`                | Recursion                                        | Data validation           |
| 2   | `02_palindrome_check.py`         | String reversing                                 | Basic data validation     |
| 3   | `03_mean_of_digits.py`           | Working with digits                              | Checksums                 |
| 4   | `04_digital_root.py`             | Repeated digit sum                               | Error detection           |
| 5   | `05_abundant_number.py`          | Sum of divisors                                  | Number theory basics      |
| 6   | `06_deficient_number.py`         | Sum of proper divisors                           | Classification            |
| 7   | `07_harshad_number.py`           | Divisible by sum of digits                       | Simple checks             |
| 8   | `08_automorphic_number.py`       | Numbers that appear at the end of their square   | Fun math                  |
| 9   | `09_pronic_number.py`            | Product of two consecutive numbers               | Pattern recognition       |
| 10  | `10_prime_factors.py`            | Finding prime factors                            | VERY IMPORTANT in RSA     |
| 11  | `11_count_distinct_primes.py`    | Count different prime factors                    | Cryptographic safety      |
| 12  | `12_prime_power.py`              | Is number of the form p^k ?                      | Used in attacks           |
| 13  | `13_mersenne_prime_tester.py`    | Check 2^p − 1 (interactive)                      | Famous large primes       |
| 14  | `14_twin_primes.py`              | Find twin prime pairs (interactive)              | Research                  |
| 15  | `15_count_divisors.py`           | Count total divisors                             | Efficiency measure        |
| 16  | `16_sum_proper_divisors.py`      | Sum of divisors except itself (interactive)      | Perfect/Amicable numbers  |
| 17  | `17_amicable_numbers.py`         | Two numbers that are friends (interactive)       | Beautiful math            |
| 18  | `18_multiplicative_persistence.py` | How many steps to single digit by multiplying  | Curiosity                 |
| 19  | `19_highly_composite_checker.py`| Slowly checks Highly Composite Numbers            | Advanced theory           |
| 20  | `20_modular_exponentiation.py`   | Fast (base^exponent) % mod (interactive)         | Core of ALL encryption    |
| 21  | `21_modular_inverse.py`          | Find number that gives 1 when multiplied mod m   | RSA decryption            |
| 22  | `22_chinese_remainder_theorem.py`| Solve system of equations                        | Used in RSA attacks       |
| 23  | `23_quadratic_residue.py`        | Euler's criterion (needs odd prime)              | Advanced crypto           |
| 24  | `24_order_modulo.py`             | Smallest k such that a^k ≡ 1 mod n               | Diffie-Hellman security   |
| 25  | `25_fibonacci_prime.py`          | Prime numbers in Fibonacci sequence              | Rare primes               |
| 26  | `26_lucas_numbers.py`            | Lucas sequence + speed/memory test               | Performance testing       |
| 27  | `27_perfect_power.py`            | Is number a perfect power (a^b)                  | Cryptographic checks      |
| 28  | `28_collatz_steps.py`            | Collatz conjecture steps + performance           | Benchmarking              |
| 29  | `29_polygonal_numbers.py`        | Triangular, square, pentagonal... numbers        | Patterns                  |
| 30  | `30_carmichael_numbers.py`       | "Fake primes" that fool bad primality tests      | Why RSA can be broken     |
| 31-32 | `31_miller_rabin.py`           | Super-fast & reliable prime test (used in real life) | Modern encryption     |
| 33  | `33_zeta_function.py`            | Approximate ζ(2) = π²/6 with performance         | Mathematical constant     |
| 34  | `34_partition_function.py`       | Number of ways to write n as sum of positives    | Advanced combinatorics    |

## Tools Used
Python 3.8+                        
VS Code               
Git & GitHub
tracemalloc            
time.perf_counter()   
math module           
random module

## Steps to Install & Run the Project

 Clone or Download the Repository

## Instruction for testing 
Open the Project Folder
- Open “Cyber Math Project” folder.
- You should see 34 Python files + this README.md.
- simply run all of the programs. 


